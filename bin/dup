#!/usr/bin/env python
from __future__ import print_function

import os
import re
import subprocess
import sys

BCK_BIN = "duplicity"
DEST_MAX_LIMIT = 99


def _is_s3_like(s: str) -> bool:
    """Return True if the string looks like an S3-style URL/scheme."""
    if not s:
        return False
    s = s.lower()
    return (
        "s3://" in s
        or "+s3://" in s
        or s.startswith("s3+http://")
        or s.startswith("s3+https://")
        or s.startswith("boto")  # boto / boto3+s3
    )


def _sanitize_options(opts: str, allow_s3: bool) -> str:
    """Drop options removed in duplicity>=2 and strip S3 flags if not allowed.
    Keeps the rest of the string unchanged.
    """
    if not opts:
        return ""
    # Remove flags that were removed in duplicity 2.0
    removed = [
        "--s3-european-buckets",
        "--s3-use-new-style",
        "--s3-use-multiprocessing",
        "--s3-multipart-max-timeout",
        "--exclude-filelist-stdin",
        "--exclude-globbing-filelist",
        "--gio",
        "--include-filelist-stdin",
        "--include-globbing-filelist",
        "--old-filenames",
        "--short-filenames",
    ]
    for flag in removed:
        opts = re.sub(
            rf"(?:^|\s){re.escape(flag)}(?:\s+\S+|=\S+)?(?=\s|$)",
            " ",
            opts,
        )
    if not allow_s3:
        # Drop any --s3-*
        opts = re.sub(r"(?:^|\s)--s3-[^\s=]+(?:=[^\s]+|\s+\S+)?", " ", opts)
    return " ".join(opts.split())


def _strip_orphan_values(opts: str) -> str:
    """Quita valores sueltos que ya no están precedidos por una flag.
    Mantiene pares válidos '--flag valor' y '--flag=valor'.
    """
    if not opts:
        return ""
    tokens = opts.split()
    cleaned = []
    for tok in tokens:
        if tok.startswith("-"):
            cleaned.append(tok)
        else:
            if cleaned and cleaned[-1].startswith("-"):
                cleaned.append(tok)
    return " ".join(cleaned)


def _set_env(index):
    uri = os.environ.get(f"DST_{index}")
    if not uri:
        return (None, None)
    # Set the valid env. vars
    target_environ_raw_names = tuple(
        filter(lambda x: x.startswith(f"DST_{index}_"), os.environ.keys())
    )
    for target_env_raw_name in target_environ_raw_names:
        env_value = os.getenv(target_env_raw_name)
        target_env_name = re.findall(r"^DST_\d+_(\w+)$", target_env_raw_name)[0]
        os.environ[target_env_name] = env_value

    # Expand shell commands from environment options
    # this resolves environment variables used in the string
    options = subprocess.check_output(
        "echo -n " + os.environ.get("OPTIONS", ""),
        shell=True,
        stderr=subprocess.STDOUT,
        text=True,
    )
    options_extra = subprocess.check_output(
        "echo -n " + os.environ.get("OPTIONS_EXTRA", ""),
        shell=True,
        stderr=subprocess.STDOUT,
        text=True,
    )
    options_extra_s3 = subprocess.check_output(
        "echo -n " + os.environ.get("OPTIONS_EXTRA_S3", ""),
        shell=True,
        stderr=subprocess.STDOUT,
        text=True,
    )

    # Set valid duplicity params
    is_s3 = _is_s3_like(uri)
    cparams = f"{options} {options_extra}"
    if is_s3:
        cparams = f"{cparams} {options_extra_s3}"
    # Remove obsolete options and strip S3 flags when not targeting S3
    cparams = _sanitize_options(cparams, allow_s3=is_s3)
    cparams = _strip_orphan_values(cparams)
    return (uri, cparams)


def _unset_env(index):
    # Set the valid env. vars
    target_environ_raw_names = tuple(
        filter(lambda x: x.startswith(f"DST_{index}_"), os.environ.keys())
    )
    for target_env_raw_name in target_environ_raw_names:
        target_env_name = re.findall(r"^DST_\d+_(\w+)$", target_env_raw_name)[0]
        os.unsetenv(target_env_name)


len_argv = len(sys.argv)
is_multi_mode = (
    (len_argv > 2 and sys.argv[2] == "multi")
    or (len_argv > 3 and sys.argv[3] == "multi")
    or False
)
if is_multi_mode:
    print("Multi-destination mode enabled")
    is_restore = sys.argv[1] == "restore"
    # In this mode we ignore args and use environment variables directly
    # Only use the $SRC arg
    if is_restore:
        # Its a restore operation
        SRC = sys.argv[3]
        EXTRA = " ".join(sys.argv[4:])
        # By default we use the first DST as the main storage from where
        # restore data
        dest, command_params = _set_env(1)
        if dest:
            command = f"{BCK_BIN} {command_params} {dest} {SRC} {EXTRA}"
            print(f"Executing: {command}")
            subprocess.check_call(command, shell=True)
        _unset_env(1)
    else:
        is_full = sys.argv[1] == "full"
        # Its a backup operation
        if is_full:
            SRC = sys.argv[2]
            EXTRA = " ".join(sys.argv[4:])
        else:
            SRC = sys.argv[1]
            EXTRA = " ".join(sys.argv[3:])
        for i in range(1, DEST_MAX_LIMIT):
            dest, command_params = _set_env(i)
            if not dest:
                # DEST must be consecutive
                break
            command = f"{BCK_BIN} {command_params} {SRC} {dest} {EXTRA}"
            print(f"Executing #{i}: {command}")
            subprocess.check_call(command, shell=True)
            _unset_env(i)
else:
    print("Single-destination mode enabled")
    # Expand shell commands from environment options
    # this resolves environment variables used in the string
    options = subprocess.check_output(
        "echo -n " + os.environ.get("OPTIONS", ""),
        shell=True,
        stderr=subprocess.STDOUT,
        text=True,
    )
    options_extra = subprocess.check_output(
        "echo -n " + os.environ.get("OPTIONS_EXTRA", ""),
        shell=True,
        stderr=subprocess.STDOUT,
        text=True,
    )
    # Sanitize options based on whether the destination looks like S3.
    # Prefer DST env var; fallback to argv if not set.
    dst_uri = os.environ.get("DST")
    allow_s3 = _is_s3_like(dst_uri or " ".join(sys.argv[1:]))
    safe_opts = _sanitize_options(f"{options} {options_extra}", allow_s3=allow_s3)
    safe_opts = _strip_orphan_values(safe_opts)
    command = f"{BCK_BIN} {safe_opts} {' '.join(sys.argv[1:])}"
    print(f"Executing: {command}")
    subprocess.check_call(command, shell=True)
