#!/usr/bin/env python
"""Run all commands extracted from environment variables when they should."""

from __future__ import unicode_literals

import logging
import re
import smtplib
import sys

from datetime import datetime
from os import environ, path
from socket import gethostname
from string import Template
from subprocess import PIPE, Popen, STDOUT

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO


logging.basicConfig(level=logging.INFO)
logging.root.name = "jobrunner"

# Get expected periodicity from this script's placement
periodicity = path.basename(path.dirname(path.abspath(__file__)))
logging.info("%s UTC - Running %s jobs", datetime.utcnow(), periodicity)

# Get email settings
smtp_host = environ.get("SMTP_HOST")
smtp_port = environ.get("SMTP_PORT")
smtp_user = environ.get("SMTP_USER")
smtp_pass = environ.get("SMTP_PASS", "")
smtp_tls = environ.get("SMTP_TLS", "").lower() in {"1", "true"}
from_ = environ.get("EMAIL_FROM")
to = environ.get("EMAIL_TO")
subject = environ.get("EMAIL_SUBJECT")

# Get the commands we need to run
to_run = dict()
for key, when in environ.items():
    match = re.match(r"^JOB_(\d+)_WHEN$", key)
    if match and periodicity in when.split():
        njob = int(match.group(1))
        to_run[njob] = environ["JOB_{}_WHAT".format(njob)]

if not to_run:
    logging.info("Nothing to do")
    sys.exit()

# Run commands in order
message = [
    "From: {}".format(from_),
    "To: {}\r\n".format(to),
]
failed = False
for njob, command in sorted(to_run.items()):
    expanded_command = Template(command).safe_substitute(environ)
    start = datetime.now()
    logging.info("Running job %d: `%s`", njob, expanded_command)
    result = StringIO()
    try:
        process = Popen(
            expanded_command, stdout=PIPE, stderr=STDOUT, shell=True,
            executable=environ.get("SHELL"), bufsize=1,
            universal_newlines=True)
        for char in iter(lambda: process.stdout.read(1), b""):
            sys.stdout.write(char)
            result.write(char)
        sys.stdout.write("\n")
        process.communicate()
        if process.returncode == 0:
            success = True
        else:
            failed = True
            success = False
    except Exception as error:
        failed = True
        success = False
        result.write(b"\n" + str(error))
        logging.exception("Failed!")
    end = datetime.now()
    log = [
        "",
        "===================================",
        "Job {}: `{}`".format(njob, expanded_command),
        "Started: {!s}".format(start),
        "Finished: {!s}".format(end),
        "Success: {!s}".format(success),
    ]
    logging.log(logging.INFO if success else logging.ERROR, "\n".join(log))
    message += log + ["", result.getvalue().decode('utf-8')]


# Report results
if all((smtp_host, smtp_port, from_, to, subject)):
    logging.info("Sending email report")
    message.insert(0, "Subject: {}".format(subject.format(
        hostname=gethostname(),
        periodicity=periodicity,
        result="ERROR" if failed else "OK",
    )))
    smtp = None
    try:
        if smtp_tls:
            smtp = smtplib.SMTP_SSL(smtp_host, smtp_port)
        else:
            smtp = smtplib.SMTP(smtp_host, smtp_port)
        if smtp_user:
            smtp.ehlo()
            smtp.login(smtp_user, smtp_pass)
        smtp.sendmail(from_, to, "\r\n".join(message))
    except:
        logging.exception("Failed sending email")
    finally:
        if smtp is not None:
            smtp.quit()
else:
    logging.info("Finished")

if failed:
    sys.exit("At least one job failed")
